我们从经典的Hello Word程序开始，1978年《C语言编程》出版的时候也是这么干的。C应该说是对Go语言产生直接影响最大的语言之一，从Hello World这个例子我们就能看出一些端倪

![](/assets/helloworld.png)

Go是一个编译语言。Go工具链会把源代码以及相关依赖包转换成为计算机底层原生机器语言的指令。这些工具链只通过一个命令来管理：go。go命令有一系列的子命令，对应各个工具集操作。最简单的子命令就是run，该命令可以编译一个或多个命名为.go的源代码文件，链接依赖库，然后运行编译结果（但是不会留下编译好的可执行文件）。我们在本书中用$符号表示命令提示符。

$ go run hellowolrd.go

毫无悬念，屏幕上将会得到一下输出：

Hello，世界

Go原生自带Unicode的处理，所以可以处理世界上各种语言的文本。

如果程序只实现性的运行一次无法满足需求，那么你应该会想要保存编译出的结果已被将来调用。那么这时就应该使用go build命令：

$ go build helloworld.go

然后一个名为helloworld的可执行的二进制文件就编译出来了，下次直接运行可执行文件即可，不用在进行重复的编译过程。

$ .\/helloworld

Hello, 世界

为了方便使用，本书的代码都标注好了名字，你可以在gopl.io\/ch1\/helloworld下获得刚才的源码。

如果你运行go get gopl.io\/ch1\/helloworld, 该命令就会从网络上对应地址获取源码，存放到本地的相应目录中。在2.6节和10.7节中会有更详细的描述。

现在我们来仔细看下这个程序本身。Go代码以包的形式来管理，包的概念和其他一些语言里库的概念或是模块的概念相似。一个包由一个或多个.go源文件组成，这些源文件放在同一个目录里，里面定义了这个包的功能实现。每一个源文件开头都是一个包的声明，在这个例子里导入声明是pacakage main， 说明了该文件所属的包叫做main。后面跟着该文件需要导入的其他包的名字，然后是代码文件本身实现的程序的声明。

Go标准库有超过100个包，涵盖各种常见任务的实现， 包括输入和输出，排序，以及文本处理。比如说fmt包里面有实现格式化打印输出的函数和扫描输入的函数。Println是fmt中的一个基本输出函数。它打印出一个或多个值，用空格隔开，在行尾会加一个换行符，这样每一个值打印出来后都会新起一行。

Package main是一个特殊的包，它定义了一个独立的可执行程序，而不是一个library。在package main 中同样有一个特殊的函数，main函数，这是一个可执行程序的入口。main所做的事情就是这个程序做的事情。当然，main通常是靠调用其他包里面的其它函数来完成这些事情的，比如调用fmt.Println.

我们必须告诉编译器当前源文件到底需要哪些package的依赖，这正是import 声明的使命，import声明跟在package 声明之后。hello world程序只是用了外部的一个包中的一个函数，但是大多数程序会依赖更多的package。

你必须精确的进行包引用。如果少了一个包，或是多饮用了一些没有用到的包，编译的时候都会出错。这个严格要求避免了程序演进的过程中越来越多的引用一些不必要的包而使得程序整体变得不必要的臃肿。

import声明必须跟在package声明的后面。在那之后会是程序的其他组成部分：函数声明， 变量， 常量， 还有类型定义（分别有各自的关键字定义： func， var， const， 还有type\);对于大多数组成部分而言，声明的顺序并不重要。示例程序很简短，只定义了一个函数，而这个函数也正好只调用了一个别的函数。为了节省空间，我们在演示时有时会隐藏package和import声明，但是源文件中肯定是有这些声明的，否则无法编译。

一个函数声明包括函数关键字func，函数名，参数列表（此例中main函数的函数列表是空列表），一个结果列表（这里也是空列表），还有函数体，也就是定义函数行为的语句们。函数体用花括号包起来。我们会在第五章仔细研究函数相关问题。

Go并不要求每一个语句后面加一个分号，除非一行写多个语句，那么前几个语句之间必须用分号隔开。事实上在编译之前带有特殊符号的换行符会被转化尾分号，所以换行符的位置在Go代码中是有讲究的。比如，开始的花括号{必须和函数声明在同一行，不能单独起一行，而在表达式x+y中，+号后面可以有换行，但是+号前面不可以（否则会把+y认成一个新的变量）。

Go在代码格式上的要求非常严格。gofmt工具会把代码转换成标准go代码格式的写法，go的fmt 子命令会给指定包中的所有源码文件进行gofmt格式化，默认值是给当前目录格式化。本书所有Go源文件都已经公国gofmt进行了格式化，你在编写自己的代码时也应该养成使用gofmt的习惯。强制使用标准格式减少了很多关于细节的无意义讨论，并且更重要的是使得自动化的代码转换变为了可能，而这在允许随意的编码格式的语言中是不可实现的。

许多文本编辑器可以配置为每次保存的时候自动运行gofmt， 这样你的代码就会永远保持标准格式了。还有一个相关的工具叫做goimports，会自动的管理引用的package，不足缺失的包，删掉多余的包。它并没有集成在标准发布版当中，不过你可以通过以下命令来获得这个命令工具：

$ go get golang.org\/x\/tools\/cmd\/goimports

对大多数用户来说，通用的操作都离不开go 工具，比如下载或是编译package，测试包，查看包的文档等等。我们会在10.7节详细看看go工具的使用。



### 1.2. 命令行参数

大多数程序本质上都是处理某种输入，然后产出某种输出。这可以看成是计算的一种定义。那么问题来了，程序是如何获得需要处理的输入数据的呢？有些程序自己产生输入数据，但是更常见的是通过一个外部的源来获取数据： 比如通过文件，通过网络连接，通过其他程序的输出，用户的键盘输入，以及命令行参数等等。接下俩的几个例子会讨论这几种不同的方式，我们先从命令行参数说起。

os包提供了和操作系统交互的函数，还可以直接获得某些和系统相关的值。这些函数和变量都是非平台相关的，也就是说在使用的时候可以不考虑所在操作系统，用法都是相同的。命令行参数可以通过os包中一个名为Args的变量获得，因此在os包之外的任何地方我们都用os.Args来访问该变量。

os.Arg是一个string组成的slice。slice是Go的一种基本类型。我们很快会详细谈到他。现在先吧slice看成是一个大小动态变化的数组s， 每一个数组元素可以通过下角标s\[i\]访问，也可以通过子序列s\[m:n\]来获取其中的一段生成一个新的slice。元素的个数通过len\(s\)获得。和大多数其他编程语言一样，Go的index也是用左闭右开区间， 这样可以简化逻辑。比如，slice s\[m:n\]包含n-m个元素。从s\[m\]到s\[n-1\]

os.Args的第一个元素是os.Args\[0\]， 就是命令名本身。os.Args剩下的其他元素就是开始执行是传入的参数。表达式s\[m:n\]表示从第m个元素到第n-1个元素组成的一个新slice。如果m或是n省略掉的话，表达式就表示从0开始或是直到len\(s\)的slice。所以，我们可以把想要的slice简记为os.Args\[1:\]。





